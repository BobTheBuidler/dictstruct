def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12 :: object
    r13, r14 :: str
    r15 :: list
    r16, r17, r18 :: ptr
    r19 :: dict
    r20 :: str
    r21 :: i32
    r22 :: bit
    r23 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L8 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('LazyDictStruct',)
    r6 = 'dictstruct._lazy'
    r7 = dictstruct.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L8 (error at <module>:1) else goto L4
L4:
    dictstruct._lazy = r8 :: module
    dec_ref r8
    r9 = ('DictStruct',)
    r10 = 'dictstruct._main'
    r11 = dictstruct.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L8 (error at <module>:2) else goto L5
L5:
    dictstruct._main = r12 :: module
    dec_ref r12
    r13 = 'DictStruct'
    r14 = 'LazyDictStruct'
    r15 = PyList_New(2)
    if is_error(r15) goto L8 (error at <module>:4) else goto L6
L6:
    r16 = get_element_ptr r15 ob_item :: PyListObject
    r17 = load_mem r16 :: ptr*
    inc_ref r13
    set_mem r17, r13 :: builtins.object*
    inc_ref r14
    r18 = r17 + 8
    set_mem r18, r14 :: builtins.object*
    r19 = dictstruct.globals :: static
    r20 = '__all__'
    r21 = CPyDict_SetItem(r19, r20, r15)
    dec_ref r15
    r22 = r21 >= 0 :: signed
    if not r22 goto L8 (error at <module>:4) else goto L7 :: bool
L7:
    return 1
L8:
    r23 = <error> :: None
    return r23

def __bool___DictStruct_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __bool___DictStruct_obj.__call__(__mypyc_self__, self):
    __mypyc_self__ :: dictstruct._main.__bool___DictStruct_obj
    self :: dictstruct._main.DictStruct
L0:
    return 1

def __contains___DictStruct_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __contains___DictStruct_obj.__call__(__mypyc_self__, self, key):
    __mypyc_self__ :: dictstruct._main.__contains___DictStruct_obj
    self :: dictstruct._main.DictStruct
    key, r0 :: str
    r1 :: object
    r2 :: tuple
    r3 :: i32
    r4 :: bit
    r5, r6 :: bool
    r7 :: object
    r8 :: bool
    r9, r10 :: object
    r11 :: bool
    r12, r13 :: bit
    r14 :: bool
L0:
    r0 = '__struct_fields__'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L14 (error at __contains__:74) else goto L1
L1:
    r2 = cast(tuple, r1)
    if is_error(r2) goto L14 (error at __contains__:74) else goto L2
L2:
    r3 = PySequence_Contains(r2, key)
    dec_ref r2
    r4 = r3 >= 0 :: signed
    if not r4 goto L14 (error at __contains__:74) else goto L3 :: bool
L3:
    r5 = truncate r3: i32 to builtins.bool
    if r5 goto L5 else goto L4 :: bool
L4:
    r6 = r5
    goto L13
L5:
    r7 = dictstruct._main.UNSET :: static
    if is_error(r7) goto L6 else goto L8
L6:
    r8 = raise NameError('value for final name "UNSET" was not set')
    if not r8 goto L14 (error at __contains__:74) else goto L7 :: bool
L7:
    unreachable
L8:
    r9 = CPyObject_GetAttr3(self, key, r7)
    if is_error(r9) goto L14 (error at __contains__:74) else goto L9
L9:
    r10 = dictstruct._main.UNSET :: static
    if is_error(r10) goto L15 else goto L12
L10:
    r11 = raise NameError('value for final name "UNSET" was not set')
    if not r11 goto L14 (error at __contains__:74) else goto L11 :: bool
L11:
    unreachable
L12:
    r12 = r9 == r10
    dec_ref r9
    r13 = r12 ^ 1
    r6 = r13
L13:
    return r6
L14:
    r14 = <error> :: bool
    return r14
L15:
    dec_ref r9
    goto L10

def get_DictStruct_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def get_DictStruct_obj.__call__(__mypyc_self__, self, key, default):
    __mypyc_self__ :: dictstruct._main.get_DictStruct_obj
    self :: dictstruct._main.DictStruct
    key :: str
    default, r0, r1, r2 :: object
L0:
    if is_error(default) goto L1 else goto L5
L1:
    r0 = box(None, 1)
    inc_ref r0
    default = r0
L2:
    r1 = CPyObject_GetAttr3(self, key, default)
    dec_ref default
    if is_error(r1) goto L4 (error at get:93) else goto L3
L3:
    return r1
L4:
    r2 = <error> :: object
    return r2
L5:
    inc_ref default
    goto L2

def __getitem___DictStruct_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __getitem___DictStruct_obj.__call__(__mypyc_self__, self, attr):
    __mypyc_self__ :: dictstruct._main.__getitem___DictStruct_obj
    self :: dictstruct._main.DictStruct
    attr :: str
    r0 :: object
    r1 :: tuple[object, object, object]
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: bit
    r6, r7 :: object
    r8 :: str
    r9 :: object
    r10 :: object[2]
    r11 :: object_ptr
    r12 :: object
    r13 :: bit
    r14 :: object
L0:
L1:
    r0 = CPyObject_GetAttr(self, attr)
    if is_error(r0) goto L3 (error at __getitem__:117) else goto L2
L2:
    return r0
L3:
    r1 = CPy_CatchError()
    r2 = builtins :: module
    r3 = 'AttributeError'
    r4 = CPyObject_GetAttr(r2, r3)
    if is_error(r4) goto L11 (error at __getitem__:118) else goto L4
L4:
    r5 = CPy_ExceptionMatches(r4)
    dec_ref r4
    if r5 goto L5 else goto L9 :: bool
L5:
    r6 = CPy_GetExcValue()
    dec_ref r6
    r7 = builtins :: module
    r8 = 'KeyError'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L11 (error at __getitem__:119) else goto L6
L6:
    r10 = [attr, self]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(r9, r11, 2, 0)
    dec_ref r9
    if is_error(r12) goto L11 (error at __getitem__:119) else goto L7
L7:
    CPy_Raise(r12)
    dec_ref r12
    if not 0 goto L11 (error at __getitem__:119) else goto L14 :: bool
L8:
    unreachable
L9:
    CPy_Reraise()
    if not 0 goto L11 else goto L15 :: bool
L10:
    unreachable
L11:
    CPy_RestoreExcInfo(r1)
    dec_ref r1
    r13 = CPy_KeepPropagating()
    if not r13 goto L13 else goto L12 :: bool
L12:
    unreachable
L13:
    r14 = <error> :: object
    return r14
L14:
    dec_ref r1
    goto L8
L15:
    dec_ref r1
    goto L10

def __getattribute___DictStruct_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __getattribute___DictStruct_obj.__call__(__mypyc_self__, self, attr):
    __mypyc_self__ :: dictstruct._main.__getattribute___DictStruct_obj
    self :: dictstruct._main.DictStruct
    attr :: str
    r0 :: object
    r1 :: bool
    r2 :: object[2]
    r3 :: object_ptr
    r4, r5 :: object
    r6 :: bool
    r7 :: bit
    r8 :: str
    r9 :: object
    r10 :: str
    r11 :: object
    r12, r13, r14, r15 :: str
    r16 :: object
    r17 :: str
    r18 :: object
    r19 :: object[1]
    r20 :: object_ptr
    r21, r22 :: object
L0:
    r0 = dictstruct._main._getattribute :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_getattribute" was not set')
    if not r1 goto L16 (error at __getattribute__:143) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = [self, attr]
    r3 = load_address r2
    r4 = PyObject_Vectorcall(r0, r3, 2, 0)
    if is_error(r4) goto L16 (error at __getattribute__:143) else goto L4
L4:
    r5 = dictstruct._main.UNSET :: static
    if is_error(r5) goto L17 else goto L7
L5:
    r6 = raise NameError('value for final name "UNSET" was not set')
    if not r6 goto L16 (error at __getattribute__:144) else goto L6 :: bool
L6:
    unreachable
L7:
    r7 = r4 == r5
    if r7 goto L18 else goto L15 :: bool
L8:
    r8 = "'"
    r9 = PyObject_Type(self)
    r10 = '__name__'
    r11 = CPyObject_GetAttr(r9, r10)
    dec_ref r9
    if is_error(r11) goto L16 (error at __getattribute__:146) else goto L9
L9:
    r12 = cast(str, r11)
    if is_error(r12) goto L16 (error at __getattribute__:146) else goto L10
L10:
    r13 = "' object has no attribute '"
    r14 = "'"
    r15 = CPyStr_Build(5, r8, r12, r13, attr, r14)
    dec_ref r12
    if is_error(r15) goto L16 (error at __getattribute__:146) else goto L11
L11:
    r16 = builtins :: module
    r17 = 'AttributeError'
    r18 = CPyObject_GetAttr(r16, r17)
    if is_error(r18) goto L19 (error at __getattribute__:145) else goto L12
L12:
    r19 = [r15]
    r20 = load_address r19
    r21 = PyObject_Vectorcall(r18, r20, 1, 0)
    dec_ref r18
    if is_error(r21) goto L19 (error at __getattribute__:145) else goto L13
L13:
    dec_ref r15
    CPy_Raise(r21)
    dec_ref r21
    if not 0 goto L16 (error at __getattribute__:145) else goto L14 :: bool
L14:
    unreachable
L15:
    return r4
L16:
    r22 = <error> :: object
    return r22
L17:
    dec_ref r4
    goto L5
L18:
    dec_ref r4
    goto L8
L19:
    dec_ref r15
    goto L16

def __setitem___DictStruct_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __setitem___DictStruct_obj.__call__(__mypyc_self__, self, attr, value):
    __mypyc_self__ :: dictstruct._main.__setitem___DictStruct_obj
    self :: dictstruct._main.DictStruct
    attr :: str
    value :: object
    r0 :: i32
    r1 :: bit
    r2 :: tuple[object, object, object]
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: bit
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: list
    r15 :: object
    r16 :: tuple
    r17 :: dict
    r18 :: object
    r19 :: bit
    r20 :: None
L0:
L1:
    r0 = PyObject_SetAttr(self, attr, value)
    r1 = r0 >= 0 :: signed
    if not r1 goto L2 (error at __setitem__:176) else goto L18 :: bool
L2:
    r2 = CPy_CatchError()
    r3 = builtins :: module
    r4 = 'AttributeError'
    r5 = CPyObject_GetAttr(r3, r4)
    if is_error(r5) goto L16 (error at __setitem__:177) else goto L3
L3:
    r6 = CPy_ExceptionMatches(r5)
    dec_ref r5
    if r6 goto L4 else goto L14 :: bool
L4:
    r7 = CPy_GetExcValue()
    r8 = 'args'
    r9 = CPyObject_GetAttr(r7, r8)
    dec_ref r7
    if is_error(r9) goto L16 (error at __setitem__:178) else goto L5
L5:
    r10 = cast(tuple, r9)
    if is_error(r10) goto L16 (error at __setitem__:178) else goto L6
L6:
    r11 = builtins :: module
    r12 = 'TypeError'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L20 (error at __setitem__:178) else goto L7
L7:
    r14 = PyList_New(0)
    if is_error(r14) goto L21 (error at __setitem__:178) else goto L8
L8:
    r15 = CPyList_Extend(r14, r10)
    dec_ref r10
    if is_error(r15) goto L22 (error at __setitem__:178) else goto L23
L9:
    r16 = PyList_AsTuple(r14)
    dec_ref r14
    if is_error(r16) goto L24 (error at __setitem__:178) else goto L10
L10:
    r17 = PyDict_New()
    if is_error(r17) goto L25 (error at __setitem__:178) else goto L11
L11:
    r18 = PyObject_Call(r13, r16, r17)
    dec_ref r13
    dec_ref r16
    dec_ref r17
    if is_error(r18) goto L16 (error at __setitem__:178) else goto L12
L12:
    CPy_Raise(r18)
    dec_ref r18
    if not 0 goto L16 (error at __setitem__:178) else goto L26 :: bool
L13:
    unreachable
L14:
    CPy_Reraise()
    if not 0 goto L16 else goto L27 :: bool
L15:
    unreachable
L16:
    CPy_RestoreExcInfo(r2)
    dec_ref r2
    r19 = CPy_KeepPropagating()
    if not r19 goto L19 else goto L17 :: bool
L17:
    unreachable
L18:
    return 1
L19:
    r20 = <error> :: None
    return r20
L20:
    dec_ref r10
    goto L16
L21:
    dec_ref r10
    dec_ref r13
    goto L16
L22:
    dec_ref r13
    dec_ref r14
    goto L16
L23:
    dec_ref r15
    goto L9
L24:
    dec_ref r13
    goto L16
L25:
    dec_ref r13
    dec_ref r16
    goto L16
L26:
    dec_ref r2
    goto L13
L27:
    dec_ref r2
    goto L15

def __iter___DictStruct_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __iter___DictStruct_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dictstruct._main.__iter___DictStruct_gen
    type, value, traceback, arg :: object
    r0 :: dictstruct._main.__iter___DictStruct_env
    r1 :: int
    r2 :: object
    r3 :: bit
    r4 :: dictstruct._main.DictStruct
    r5 :: str
    r6 :: object
    r7 :: tuple
    r8, r9 :: bool
    r10 :: tuple
    r11 :: ptr
    r12 :: native_int
    r13, r14 :: short_int
    r15 :: bit
    r16 :: tuple
    r17 :: short_int
    r18 :: object
    r19 :: str
    r20 :: bool
    r21 :: dictstruct._main.DictStruct
    r22 :: str
    r23 :: object
    r24 :: bool
    r25 :: object
    r26 :: bool
    r27, r28 :: object
    r29 :: bool
    r30, r31 :: bit
    r32 :: str
    r33 :: bool
    r34 :: object
    r35 :: bit
    r36, r37 :: short_int
    r38 :: bool
    r39 :: object
    r40 :: bool
    r41, r42 :: bit
    r43 :: bool
    r44 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L45 (error at __iter__:180) else goto L1
L1:
    r1 = r0.__mypyc_next_label__
    if is_error(r1) goto L46 (error at __iter__:180) else goto L41
L2:
    r2 = load_address _Py_NoneStruct
    r3 = type != r2
    if r3 goto L47 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L45 (error at __iter__:180) else goto L4 :: bool
L4:
    unreachable
L5:
    r4 = r0.self
    if is_error(r4) goto L46 (error at __iter__:195) else goto L6
L6:
    r5 = '__struct_fields__'
    r6 = CPyObject_GetAttr(r4, r5)
    dec_ref r4
    if is_error(r6) goto L46 (error at __iter__:195) else goto L7
L7:
    r7 = cast(tuple, r6)
    if is_error(r7) goto L46 (error at __iter__:195) else goto L8
L8:
    r0.__mypyc_temp__0 = r7; r8 = is_error
    if not r8 goto L46 (error at __iter__:-1) else goto L9 :: bool
L9:
    r0.__mypyc_temp__1 = 0; r9 = is_error
    if not r9 goto L46 (error at __iter__:-1) else goto L10 :: bool
L10:
    r10 = r0.__mypyc_temp__0
    if is_error(r10) goto L46 (error at __iter__:195) else goto L11
L11:
    r11 = get_element_ptr r10 ob_size :: PyVarObject
    r12 = load_mem r11 :: native_int*
    dec_ref r10
    r13 = r12 << 1
    r14 = r0.__mypyc_temp__1
    if is_error(r14) goto L46 (error at __iter__:195) else goto L12
L12:
    r15 = r14 < r13 :: signed
    if r15 goto L13 else goto L38 :: bool
L13:
    r16 = r0.__mypyc_temp__0
    if is_error(r16) goto L46 (error at __iter__:195) else goto L14
L14:
    r17 = r0.__mypyc_temp__1
    if is_error(r17) goto L48 (error at __iter__:195) else goto L15
L15:
    r18 = CPySequenceTuple_GetItem(r16, r17)
    dec_ref r16
    if is_error(r18) goto L46 (error at __iter__:195) else goto L16
L16:
    r19 = cast(str, r18)
    if is_error(r19) goto L46 (error at __iter__:195) else goto L17
L17:
    r0.field = r19; r20 = is_error
    if not r20 goto L46 (error at __iter__:195) else goto L18 :: bool
L18:
    r21 = r0.self
    if is_error(r21) goto L46 (error at __iter__:196) else goto L19
L19:
    r22 = r0.field
    if is_error(r22) goto L49 (error at __iter__:196) else goto L20
L20:
    r23 = dictstruct._main.UNSET :: static
    if is_error(r23) goto L50 else goto L23
L21:
    r24 = raise NameError('value for final name "UNSET" was not set')
    if not r24 goto L45 (error at __iter__:196) else goto L22 :: bool
L22:
    unreachable
L23:
    r25 = CPyObject_GetAttr3(r21, r22, r23)
    dec_ref r21
    dec_ref r22
    if is_error(r25) goto L46 (error at __iter__:196) else goto L24
L24:
    r0.value = r25; r26 = is_error
    if not r26 goto L46 (error at __iter__:196) else goto L25 :: bool
L25:
    r27 = r0.value
    if is_error(r27) goto L46 (error at __iter__:197) else goto L26
L26:
    r28 = dictstruct._main.UNSET :: static
    if is_error(r28) goto L51 else goto L29
L27:
    r29 = raise NameError('value for final name "UNSET" was not set')
    if not r29 goto L45 (error at __iter__:197) else goto L28 :: bool
L28:
    unreachable
L29:
    r30 = r27 == r28
    dec_ref r27
    r31 = r30 ^ 1
    if r31 goto L30 else goto L36 :: bool
L30:
    r32 = r0.field
    if is_error(r32) goto L46 (error at __iter__:198) else goto L31
L31:
    r0.__mypyc_next_label__ = 2; r33 = is_error
    dec_ref r0
    if not r33 goto L52 (error at __iter__:198) else goto L32 :: bool
L32:
    return r32
L33:
    r34 = load_address _Py_NoneStruct
    r35 = type != r34
    if r35 goto L53 else goto L36 :: bool
L34:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L45 (error at __iter__:198) else goto L35 :: bool
L35:
    unreachable
L36:
    r36 = r0.__mypyc_temp__1
    if is_error(r36) goto L46 (error at __iter__:195) else goto L37
L37:
    r37 = r36 + 2
    r0.__mypyc_temp__1 = r37; r38 = is_error
    if not r38 goto L46 (error at __iter__:195) else goto L10 :: bool
L38:
    r39 = box(None, 1)
    r0.__mypyc_next_label__ = -2; r40 = is_error
    dec_ref r0
    if not r40 goto L45 (error at __iter__:180) else goto L39 :: bool
L39:
    CPyGen_SetStopIterationValue(r39)
    if not 0 goto L45 else goto L40 :: bool
L40:
    unreachable
L41:
    r41 = r1 == 0
    if r41 goto L54 else goto L42 :: bool
L42:
    r42 = r1 == 2
    dec_ref r1 :: int
    if r42 goto L33 else goto L55 :: bool
L43:
    r43 = raise StopIteration
    if not r43 goto L45 (error at __iter__:180) else goto L44 :: bool
L44:
    unreachable
L45:
    r44 = <error> :: object
    return r44
L46:
    dec_ref r0
    goto L45
L47:
    dec_ref r0
    goto L3
L48:
    dec_ref r0
    dec_ref r16
    goto L45
L49:
    dec_ref r0
    dec_ref r21
    goto L45
L50:
    dec_ref r0
    dec_ref r21
    dec_ref r22
    goto L21
L51:
    dec_ref r0
    dec_ref r27
    goto L27
L52:
    dec_ref r32
    goto L45
L53:
    dec_ref r0
    goto L34
L54:
    dec_ref r1 :: int
    goto L2
L55:
    dec_ref r0
    goto L43

def __iter___DictStruct_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dictstruct._main.__iter___DictStruct_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __iter___DictStruct_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __iter___DictStruct_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dictstruct._main.__iter___DictStruct_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __iter___DictStruct_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __iter___DictStruct_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dictstruct._main.__iter___DictStruct_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def __iter___DictStruct_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dictstruct._main.__iter___DictStruct_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = __iter___DictStruct_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def __iter___DictStruct_gen.close(__mypyc_self__):
    __mypyc_self__ :: dictstruct._main.__iter___DictStruct_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def __iter___DictStruct_obj.__call__(__mypyc_self__, self):
    __mypyc_self__ :: dictstruct._main.__iter___DictStruct_obj
    self :: dictstruct._main.DictStruct
    r0 :: dictstruct._main.__iter___DictStruct_env
    r1 :: bool
    r2 :: dictstruct._main.__iter___DictStruct_gen
    r3, r4 :: bool
    r5 :: object
L0:
    r0 = __iter___DictStruct_env()
    if is_error(r0) goto L6 (error at __iter__:180) else goto L1
L1:
    inc_ref self
    r0.self = self; r1 = is_error
    if not r1 goto L7 (error at __iter__:180) else goto L2 :: bool
L2:
    r2 = __iter___DictStruct_gen()
    if is_error(r2) goto L7 (error at __iter__:180) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L8 (error at __iter__:180) else goto L4 :: bool
L4:
    r0.__mypyc_next_label__ = 0; r4 = is_error
    dec_ref r0
    if not r4 goto L9 (error at __iter__:180) else goto L5 :: bool
L5:
    return r2
L6:
    r5 = <error> :: object
    return r5
L7:
    dec_ref r0
    goto L6
L8:
    dec_ref r0
    dec_ref r2
    goto L6
L9:
    dec_ref r2
    goto L6

def __len___DictStruct_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __len___DictStruct_obj.__call__(__mypyc_self__, self):
    __mypyc_self__ :: dictstruct._main.__len___DictStruct_obj
    self :: dictstruct._main.DictStruct
    r0 :: list
    r1, r2 :: object
    r3 :: str
    r4 :: i32
    r5, r6 :: bit
    r7 :: ptr
    r8 :: native_int
    r9 :: short_int
    r10 :: int
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L7 (error at __len__:212) else goto L1
L1:
    r1 = PyObject_GetIter(self)
    if is_error(r1) goto L8 (error at __len__:212) else goto L2
L2:
    r2 = PyIter_Next(r1)
    if is_error(r2) goto L9 else goto L3
L3:
    r3 = borrow cast(str, r2)
    if is_error(r3) goto L10 (error at __len__:212) else goto L4
L4:
    inc_ref r3
    dec_ref r2
    r4 = PyList_Append(r0, r3)
    dec_ref r3
    r5 = r4 >= 0 :: signed
    if not r5 goto L11 (error at __len__:212) else goto L2 :: bool
L5:
    r6 = CPy_NoErrOccurred()
    if not r6 goto L8 (error at __len__:212) else goto L6 :: bool
L6:
    r7 = get_element_ptr r0 ob_size :: PyVarObject
    r8 = load_mem r7 :: native_int*
    dec_ref r0
    r9 = r8 << 1
    return r9
L7:
    r10 = <error> :: int
    return r10
L8:
    dec_ref r0
    goto L7
L9:
    dec_ref r1
    goto L5
L10:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    goto L7
L11:
    dec_ref r0
    dec_ref r1
    goto L7

def keys_DictStruct_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def keys_DictStruct_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dictstruct._main.keys_DictStruct_gen
    type, value, traceback, arg, r0, r1 :: object
    r2 :: dictstruct._main.keys_DictStruct_env
    r3 :: int
    r4 :: object
    r5 :: bit
    r6 :: dictstruct._main.DictStruct
    r7 :: object
    r8 :: bool
    r9, r10, r11, r12, r13 :: object
    r14 :: bool
    r15 :: object
    r16 :: bit
    r17 :: tuple[object, object, object]
    r18 :: bool
    r19 :: object_ptr
    r20 :: object
    r21 :: bool
    r22, r23, r24 :: tuple[object, object, object]
    r25 :: bit
    r26, r27, r28, r29 :: object
    r30 :: bool
    r31, r32 :: bit
    r33 :: bool
    r34 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = __mypyc_self__.__mypyc_env__
    if is_error(r2) goto L43 (error at keys:214) else goto L1
L1:
    r3 = r2.__mypyc_next_label__
    if is_error(r3) goto L44 (error at keys:214) else goto L38
L2:
    r4 = load_address _Py_NoneStruct
    r5 = type != r4
    if r5 goto L45 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L42 (error at keys:214) else goto L4 :: bool
L4:
    unreachable
L5:
    r6 = r2.self
    if is_error(r6) goto L44 (error at keys:226) else goto L6
L6:
    r7 = PyObject_GetIter(r6)
    dec_ref r6
    if is_error(r7) goto L44 (error at keys:226) else goto L7
L7:
    r2.__mypyc_temp__2 = r7; r8 = is_error
    if not r8 goto L44 (error at keys:-1) else goto L8 :: bool
L8:
    r9 = r2.__mypyc_temp__2
    if is_error(r9) goto L44 (error at keys:-1) else goto L9
L9:
    r10 = CPyIter_Next(r9)
    dec_ref r9
    if is_error(r10) goto L46 else goto L12
L10:
    r11 = CPy_FetchStopIterationValue()
    if is_error(r11) goto L47 (error at keys:226) else goto L11
L11:
    r12 = r11
    dec_ref r12
    goto L35
L12:
    r13 = r10
L13:
    r2.__mypyc_next_label__ = 2; r14 = is_error
    if not r14 goto L48 (error at keys:226) else goto L49 :: bool
L14:
    return r13
L15:
    r15 = load_address _Py_NoneStruct
    r16 = type != r15
    if r16 goto L16 else goto L18 :: bool
L16:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L19 (error at keys:226) else goto L50 :: bool
L17:
    unreachable
L18:
    inc_ref arg
    goto L30
L19:
    r17 = CPy_CatchError()
    r2.__mypyc_temp__3 = r17; r18 = is_error
    if not r18 goto L51 (error at keys:-1) else goto L20 :: bool
L20:
    r19 = load_address r1
    r20 = r2.__mypyc_temp__2
    if is_error(r20) goto L51 (error at keys:-1) else goto L21
L21:
    r21 = CPy_YieldFromErrorHandle(r20, r19)
    dec_ref r20
    if is_error(r21) goto L51 (error at keys:226) else goto L22
L22:
    if r21 goto L25 else goto L23 :: bool
L23:
    inc_ref r1
    r13 = r1
    r22 = r2.__mypyc_temp__3
    if is_error(r22) goto L52 (error at keys:-1) else goto L24
L24:
    CPy_RestoreExcInfo(r22)
    dec_ref r22
    goto L13
L25:
    r12 = r1
    dec_ref r12
    r23 = r2.__mypyc_temp__3
    if is_error(r23) goto L27 (error at keys:-1) else goto L26
L26:
    CPy_RestoreExcInfo(r23)
    dec_ref r23
    goto L35
L27:
    r24 = r2.__mypyc_temp__3
    dec_ref r2
    if is_error(r24) goto L42 (error at keys:-1) else goto L28
L28:
    CPy_RestoreExcInfo(r24)
    dec_ref r24
    r25 = CPy_KeepPropagating()
    if not r25 goto L42 else goto L29 :: bool
L29:
    unreachable
L30:
    r26 = r2.__mypyc_temp__2
    if is_error(r26) goto L53 (error at keys:-1) else goto L31
L31:
    r27 = CPyIter_Send(r26, arg)
    dec_ref r26
    dec_ref arg
    if is_error(r27) goto L54 else goto L32
L32:
    r13 = r27
    goto L13
L33:
    r28 = CPy_FetchStopIterationValue()
    if is_error(r28) goto L47 (error at keys:226) else goto L34
L34:
    r12 = r28
    dec_ref r12
L35:
    r29 = box(None, 1)
    r2.__mypyc_next_label__ = -2; r30 = is_error
    dec_ref r2
    if not r30 goto L42 (error at keys:214) else goto L36 :: bool
L36:
    CPyGen_SetStopIterationValue(r29)
    if not 0 goto L42 else goto L37 :: bool
L37:
    unreachable
L38:
    r31 = r3 == 0
    if r31 goto L55 else goto L39 :: bool
L39:
    r32 = r3 == 2
    dec_ref r3 :: int
    if r32 goto L15 else goto L56 :: bool
L40:
    r33 = raise StopIteration
    if not r33 goto L42 (error at keys:214) else goto L41 :: bool
L41:
    unreachable
L42:
    r34 = <error> :: object
    return r34
L43:
    xdec_ref r1
    goto L42
L44:
    xdec_ref r1
    dec_ref r2
    goto L42
L45:
    xdec_ref r1
    dec_ref r2
    goto L3
L46:
    xdec_ref r1
    goto L10
L47:
    dec_ref r2
    goto L42
L48:
    dec_ref r13
    goto L19
L49:
    xdec_ref r1
    dec_ref r2
    goto L14
L50:
    xdec_ref r1
    dec_ref r2
    goto L17
L51:
    xdec_ref r1
    goto L27
L52:
    xdec_ref r1
    dec_ref r13
    goto L27
L53:
    xdec_ref r1
    dec_ref r2
    dec_ref arg
    goto L42
L54:
    xdec_ref r1
    goto L33
L55:
    dec_ref r3 :: int
    goto L2
L56:
    xdec_ref r1
    dec_ref r2
    goto L40

def keys_DictStruct_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dictstruct._main.keys_DictStruct_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = keys_DictStruct_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def keys_DictStruct_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dictstruct._main.keys_DictStruct_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = keys_DictStruct_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def keys_DictStruct_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dictstruct._main.keys_DictStruct_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def keys_DictStruct_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dictstruct._main.keys_DictStruct_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = keys_DictStruct_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def keys_DictStruct_gen.close(__mypyc_self__):
    __mypyc_self__ :: dictstruct._main.keys_DictStruct_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def keys_DictStruct_obj.__call__(__mypyc_self__, self):
    __mypyc_self__ :: dictstruct._main.keys_DictStruct_obj
    self :: dictstruct._main.DictStruct
    r0 :: dictstruct._main.keys_DictStruct_env
    r1 :: bool
    r2 :: dictstruct._main.keys_DictStruct_gen
    r3, r4 :: bool
    r5 :: object
L0:
    r0 = keys_DictStruct_env()
    if is_error(r0) goto L6 (error at keys:214) else goto L1
L1:
    inc_ref self
    r0.self = self; r1 = is_error
    if not r1 goto L7 (error at keys:214) else goto L2 :: bool
L2:
    r2 = keys_DictStruct_gen()
    if is_error(r2) goto L7 (error at keys:214) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L8 (error at keys:214) else goto L4 :: bool
L4:
    r0.__mypyc_next_label__ = 0; r4 = is_error
    dec_ref r0
    if not r4 goto L9 (error at keys:214) else goto L5 :: bool
L5:
    return r2
L6:
    r5 = <error> :: object
    return r5
L7:
    dec_ref r0
    goto L6
L8:
    dec_ref r0
    dec_ref r2
    goto L6
L9:
    dec_ref r2
    goto L6

def items_DictStruct_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def items_DictStruct_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dictstruct._main.items_DictStruct_gen
    type, value, traceback, arg :: object
    r0 :: dictstruct._main.items_DictStruct_env
    r1 :: int
    r2 :: object
    r3 :: bit
    r4 :: dictstruct._main.DictStruct
    r5 :: str
    r6 :: object
    r7 :: tuple
    r8, r9 :: bool
    r10 :: tuple
    r11 :: ptr
    r12 :: native_int
    r13, r14 :: short_int
    r15 :: bit
    r16 :: tuple
    r17 :: short_int
    r18 :: object
    r19 :: str
    r20 :: bool
    r21 :: dictstruct._main.DictStruct
    r22 :: str
    r23 :: object
    r24 :: bool
    r25 :: object
    r26 :: bool
    r27, r28 :: object
    r29 :: bool
    r30, r31 :: bit
    r32 :: str
    r33 :: object
    r34 :: tuple[str, object]
    r35 :: object
    r36 :: bool
    r37 :: object
    r38 :: bit
    r39, r40 :: short_int
    r41 :: bool
    r42 :: object
    r43 :: bool
    r44, r45 :: bit
    r46 :: bool
    r47 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L46 (error at items:228) else goto L1
L1:
    r1 = r0.__mypyc_next_label__
    if is_error(r1) goto L47 (error at items:228) else goto L42
L2:
    r2 = load_address _Py_NoneStruct
    r3 = type != r2
    if r3 goto L48 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L46 (error at items:228) else goto L4 :: bool
L4:
    unreachable
L5:
    r4 = r0.self
    if is_error(r4) goto L47 (error at items:240) else goto L6
L6:
    r5 = '__struct_fields__'
    r6 = CPyObject_GetAttr(r4, r5)
    dec_ref r4
    if is_error(r6) goto L47 (error at items:240) else goto L7
L7:
    r7 = cast(tuple, r6)
    if is_error(r7) goto L47 (error at items:240) else goto L8
L8:
    r0.__mypyc_temp__4 = r7; r8 = is_error
    if not r8 goto L47 (error at items:-1) else goto L9 :: bool
L9:
    r0.__mypyc_temp__5 = 0; r9 = is_error
    if not r9 goto L47 (error at items:-1) else goto L10 :: bool
L10:
    r10 = r0.__mypyc_temp__4
    if is_error(r10) goto L47 (error at items:240) else goto L11
L11:
    r11 = get_element_ptr r10 ob_size :: PyVarObject
    r12 = load_mem r11 :: native_int*
    dec_ref r10
    r13 = r12 << 1
    r14 = r0.__mypyc_temp__5
    if is_error(r14) goto L47 (error at items:240) else goto L12
L12:
    r15 = r14 < r13 :: signed
    if r15 goto L13 else goto L39 :: bool
L13:
    r16 = r0.__mypyc_temp__4
    if is_error(r16) goto L47 (error at items:240) else goto L14
L14:
    r17 = r0.__mypyc_temp__5
    if is_error(r17) goto L49 (error at items:240) else goto L15
L15:
    r18 = CPySequenceTuple_GetItem(r16, r17)
    dec_ref r16
    if is_error(r18) goto L47 (error at items:240) else goto L16
L16:
    r19 = cast(str, r18)
    if is_error(r19) goto L47 (error at items:240) else goto L17
L17:
    r0.key = r19; r20 = is_error
    if not r20 goto L47 (error at items:240) else goto L18 :: bool
L18:
    r21 = r0.self
    if is_error(r21) goto L47 (error at items:241) else goto L19
L19:
    r22 = r0.key
    if is_error(r22) goto L50 (error at items:241) else goto L20
L20:
    r23 = dictstruct._main.UNSET :: static
    if is_error(r23) goto L51 else goto L23
L21:
    r24 = raise NameError('value for final name "UNSET" was not set')
    if not r24 goto L46 (error at items:241) else goto L22 :: bool
L22:
    unreachable
L23:
    r25 = CPyObject_GetAttr3(r21, r22, r23)
    dec_ref r21
    dec_ref r22
    if is_error(r25) goto L47 (error at items:241) else goto L24
L24:
    r0.value = r25; r26 = is_error
    if not r26 goto L47 (error at items:241) else goto L25 :: bool
L25:
    r27 = r0.value
    if is_error(r27) goto L47 (error at items:242) else goto L26
L26:
    r28 = dictstruct._main.UNSET :: static
    if is_error(r28) goto L52 else goto L29
L27:
    r29 = raise NameError('value for final name "UNSET" was not set')
    if not r29 goto L46 (error at items:242) else goto L28 :: bool
L28:
    unreachable
L29:
    r30 = r27 == r28
    dec_ref r27
    r31 = r30 ^ 1
    if r31 goto L30 else goto L37 :: bool
L30:
    r32 = r0.key
    if is_error(r32) goto L47 (error at items:243) else goto L31
L31:
    r33 = r0.value
    if is_error(r33) goto L53 (error at items:243) else goto L32
L32:
    r34 = (r32, r33)
    r35 = box(tuple[str, object], r34)
    r0.__mypyc_next_label__ = 2; r36 = is_error
    dec_ref r0
    if not r36 goto L54 (error at items:243) else goto L33 :: bool
L33:
    return r35
L34:
    r37 = load_address _Py_NoneStruct
    r38 = type != r37
    if r38 goto L55 else goto L37 :: bool
L35:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L46 (error at items:243) else goto L36 :: bool
L36:
    unreachable
L37:
    r39 = r0.__mypyc_temp__5
    if is_error(r39) goto L47 (error at items:240) else goto L38
L38:
    r40 = r39 + 2
    r0.__mypyc_temp__5 = r40; r41 = is_error
    if not r41 goto L47 (error at items:240) else goto L10 :: bool
L39:
    r42 = box(None, 1)
    r0.__mypyc_next_label__ = -2; r43 = is_error
    dec_ref r0
    if not r43 goto L46 (error at items:228) else goto L40 :: bool
L40:
    CPyGen_SetStopIterationValue(r42)
    if not 0 goto L46 else goto L41 :: bool
L41:
    unreachable
L42:
    r44 = r1 == 0
    if r44 goto L56 else goto L43 :: bool
L43:
    r45 = r1 == 2
    dec_ref r1 :: int
    if r45 goto L34 else goto L57 :: bool
L44:
    r46 = raise StopIteration
    if not r46 goto L46 (error at items:228) else goto L45 :: bool
L45:
    unreachable
L46:
    r47 = <error> :: object
    return r47
L47:
    dec_ref r0
    goto L46
L48:
    dec_ref r0
    goto L3
L49:
    dec_ref r0
    dec_ref r16
    goto L46
L50:
    dec_ref r0
    dec_ref r21
    goto L46
L51:
    dec_ref r0
    dec_ref r21
    dec_ref r22
    goto L21
L52:
    dec_ref r0
    dec_ref r27
    goto L27
L53:
    dec_ref r0
    dec_ref r32
    goto L46
L54:
    dec_ref r35
    goto L46
L55:
    dec_ref r0
    goto L35
L56:
    dec_ref r1 :: int
    goto L2
L57:
    dec_ref r0
    goto L44

def items_DictStruct_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dictstruct._main.items_DictStruct_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = items_DictStruct_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def items_DictStruct_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dictstruct._main.items_DictStruct_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = items_DictStruct_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def items_DictStruct_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dictstruct._main.items_DictStruct_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def items_DictStruct_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dictstruct._main.items_DictStruct_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = items_DictStruct_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def items_DictStruct_gen.close(__mypyc_self__):
    __mypyc_self__ :: dictstruct._main.items_DictStruct_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def items_DictStruct_obj.__call__(__mypyc_self__, self):
    __mypyc_self__ :: dictstruct._main.items_DictStruct_obj
    self :: dictstruct._main.DictStruct
    r0 :: dictstruct._main.items_DictStruct_env
    r1 :: bool
    r2 :: dictstruct._main.items_DictStruct_gen
    r3, r4 :: bool
    r5 :: object
L0:
    r0 = items_DictStruct_env()
    if is_error(r0) goto L6 (error at items:228) else goto L1
L1:
    inc_ref self
    r0.self = self; r1 = is_error
    if not r1 goto L7 (error at items:228) else goto L2 :: bool
L2:
    r2 = items_DictStruct_gen()
    if is_error(r2) goto L7 (error at items:228) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L8 (error at items:228) else goto L4 :: bool
L4:
    r0.__mypyc_next_label__ = 0; r4 = is_error
    dec_ref r0
    if not r4 goto L9 (error at items:228) else goto L5 :: bool
L5:
    return r2
L6:
    r5 = <error> :: object
    return r5
L7:
    dec_ref r0
    goto L6
L8:
    dec_ref r0
    dec_ref r2
    goto L6
L9:
    dec_ref r2
    goto L6

def values_DictStruct_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def values_DictStruct_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dictstruct._main.values_DictStruct_gen
    type, value, traceback, arg :: object
    r0 :: dictstruct._main.values_DictStruct_env
    r1 :: int
    r2 :: object
    r3 :: bit
    r4 :: dictstruct._main.DictStruct
    r5 :: str
    r6 :: object
    r7 :: tuple
    r8, r9 :: bool
    r10 :: tuple
    r11 :: ptr
    r12 :: native_int
    r13, r14 :: short_int
    r15 :: bit
    r16 :: tuple
    r17 :: short_int
    r18 :: object
    r19 :: str
    r20 :: bool
    r21 :: dictstruct._main.DictStruct
    r22 :: str
    r23 :: object
    r24 :: bool
    r25 :: object
    r26 :: bool
    r27, r28 :: object
    r29 :: bool
    r30, r31 :: bit
    r32 :: object
    r33 :: bool
    r34 :: object
    r35 :: bit
    r36, r37 :: short_int
    r38 :: bool
    r39 :: object
    r40 :: bool
    r41, r42 :: bit
    r43 :: bool
    r44 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L45 (error at values:245) else goto L1
L1:
    r1 = r0.__mypyc_next_label__
    if is_error(r1) goto L46 (error at values:245) else goto L41
L2:
    r2 = load_address _Py_NoneStruct
    r3 = type != r2
    if r3 goto L47 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L45 (error at values:245) else goto L4 :: bool
L4:
    unreachable
L5:
    r4 = r0.self
    if is_error(r4) goto L46 (error at values:257) else goto L6
L6:
    r5 = '__struct_fields__'
    r6 = CPyObject_GetAttr(r4, r5)
    dec_ref r4
    if is_error(r6) goto L46 (error at values:257) else goto L7
L7:
    r7 = cast(tuple, r6)
    if is_error(r7) goto L46 (error at values:257) else goto L8
L8:
    r0.__mypyc_temp__6 = r7; r8 = is_error
    if not r8 goto L46 (error at values:-1) else goto L9 :: bool
L9:
    r0.__mypyc_temp__7 = 0; r9 = is_error
    if not r9 goto L46 (error at values:-1) else goto L10 :: bool
L10:
    r10 = r0.__mypyc_temp__6
    if is_error(r10) goto L46 (error at values:257) else goto L11
L11:
    r11 = get_element_ptr r10 ob_size :: PyVarObject
    r12 = load_mem r11 :: native_int*
    dec_ref r10
    r13 = r12 << 1
    r14 = r0.__mypyc_temp__7
    if is_error(r14) goto L46 (error at values:257) else goto L12
L12:
    r15 = r14 < r13 :: signed
    if r15 goto L13 else goto L38 :: bool
L13:
    r16 = r0.__mypyc_temp__6
    if is_error(r16) goto L46 (error at values:257) else goto L14
L14:
    r17 = r0.__mypyc_temp__7
    if is_error(r17) goto L48 (error at values:257) else goto L15
L15:
    r18 = CPySequenceTuple_GetItem(r16, r17)
    dec_ref r16
    if is_error(r18) goto L46 (error at values:257) else goto L16
L16:
    r19 = cast(str, r18)
    if is_error(r19) goto L46 (error at values:257) else goto L17
L17:
    r0.key = r19; r20 = is_error
    if not r20 goto L46 (error at values:257) else goto L18 :: bool
L18:
    r21 = r0.self
    if is_error(r21) goto L46 (error at values:258) else goto L19
L19:
    r22 = r0.key
    if is_error(r22) goto L49 (error at values:258) else goto L20
L20:
    r23 = dictstruct._main.UNSET :: static
    if is_error(r23) goto L50 else goto L23
L21:
    r24 = raise NameError('value for final name "UNSET" was not set')
    if not r24 goto L45 (error at values:258) else goto L22 :: bool
L22:
    unreachable
L23:
    r25 = CPyObject_GetAttr3(r21, r22, r23)
    dec_ref r21
    dec_ref r22
    if is_error(r25) goto L46 (error at values:258) else goto L24
L24:
    r0.value = r25; r26 = is_error
    if not r26 goto L46 (error at values:258) else goto L25 :: bool
L25:
    r27 = r0.value
    if is_error(r27) goto L46 (error at values:259) else goto L26
L26:
    r28 = dictstruct._main.UNSET :: static
    if is_error(r28) goto L51 else goto L29
L27:
    r29 = raise NameError('value for final name "UNSET" was not set')
    if not r29 goto L45 (error at values:259) else goto L28 :: bool
L28:
    unreachable
L29:
    r30 = r27 == r28
    dec_ref r27
    r31 = r30 ^ 1
    if r31 goto L30 else goto L36 :: bool
L30:
    r32 = r0.value
    if is_error(r32) goto L46 (error at values:260) else goto L31
L31:
    r0.__mypyc_next_label__ = 2; r33 = is_error
    dec_ref r0
    if not r33 goto L52 (error at values:260) else goto L32 :: bool
L32:
    return r32
L33:
    r34 = load_address _Py_NoneStruct
    r35 = type != r34
    if r35 goto L53 else goto L36 :: bool
L34:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L45 (error at values:260) else goto L35 :: bool
L35:
    unreachable
L36:
    r36 = r0.__mypyc_temp__7
    if is_error(r36) goto L46 (error at values:257) else goto L37
L37:
    r37 = r36 + 2
    r0.__mypyc_temp__7 = r37; r38 = is_error
    if not r38 goto L46 (error at values:257) else goto L10 :: bool
L38:
    r39 = box(None, 1)
    r0.__mypyc_next_label__ = -2; r40 = is_error
    dec_ref r0
    if not r40 goto L45 (error at values:245) else goto L39 :: bool
L39:
    CPyGen_SetStopIterationValue(r39)
    if not 0 goto L45 else goto L40 :: bool
L40:
    unreachable
L41:
    r41 = r1 == 0
    if r41 goto L54 else goto L42 :: bool
L42:
    r42 = r1 == 2
    dec_ref r1 :: int
    if r42 goto L33 else goto L55 :: bool
L43:
    r43 = raise StopIteration
    if not r43 goto L45 (error at values:245) else goto L44 :: bool
L44:
    unreachable
L45:
    r44 = <error> :: object
    return r44
L46:
    dec_ref r0
    goto L45
L47:
    dec_ref r0
    goto L3
L48:
    dec_ref r0
    dec_ref r16
    goto L45
L49:
    dec_ref r0
    dec_ref r21
    goto L45
L50:
    dec_ref r0
    dec_ref r21
    dec_ref r22
    goto L21
L51:
    dec_ref r0
    dec_ref r27
    goto L27
L52:
    dec_ref r32
    goto L45
L53:
    dec_ref r0
    goto L34
L54:
    dec_ref r1 :: int
    goto L2
L55:
    dec_ref r0
    goto L43

def values_DictStruct_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dictstruct._main.values_DictStruct_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = values_DictStruct_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def values_DictStruct_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dictstruct._main.values_DictStruct_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = values_DictStruct_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def values_DictStruct_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dictstruct._main.values_DictStruct_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def values_DictStruct_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dictstruct._main.values_DictStruct_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = values_DictStruct_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def values_DictStruct_gen.close(__mypyc_self__):
    __mypyc_self__ :: dictstruct._main.values_DictStruct_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def values_DictStruct_obj.__call__(__mypyc_self__, self):
    __mypyc_self__ :: dictstruct._main.values_DictStruct_obj
    self :: dictstruct._main.DictStruct
    r0 :: dictstruct._main.values_DictStruct_env
    r1 :: bool
    r2 :: dictstruct._main.values_DictStruct_gen
    r3, r4 :: bool
    r5 :: object
L0:
    r0 = values_DictStruct_env()
    if is_error(r0) goto L6 (error at values:245) else goto L1
L1:
    inc_ref self
    r0.self = self; r1 = is_error
    if not r1 goto L7 (error at values:245) else goto L2 :: bool
L2:
    r2 = values_DictStruct_gen()
    if is_error(r2) goto L7 (error at values:245) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L8 (error at values:245) else goto L4 :: bool
L4:
    r0.__mypyc_next_label__ = 0; r4 = is_error
    dec_ref r0
    if not r4 goto L9 (error at values:245) else goto L5 :: bool
L5:
    return r2
L6:
    r5 = <error> :: object
    return r5
L7:
    dec_ref r0
    goto L6
L8:
    dec_ref r0
    dec_ref r2
    goto L6
L9:
    dec_ref r2
    goto L6

def __hash___DictStruct_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __hash___DictStruct_obj.__call__(__mypyc_self__, self):
    __mypyc_self__ :: dictstruct._main.__hash___DictStruct_obj
    self :: dictstruct._main.DictStruct
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: bool
    r5 :: str
    r6 :: object
    r7 :: str
    r8 :: object
    r9, r10, r11 :: str
    r12 :: object
    r13 :: str
    r14 :: object
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: dict
    r21 :: str
    r22 :: object
    cached_hash :: union[object, None]
    r23 :: i32
    r24 :: bit
    r25 :: bool
    r26 :: int
    r27 :: str
    r28 :: object
    r29 :: tuple
    r30 :: ptr
    r31 :: native_int
    r32 :: list
    r33 :: short_int
    r34 :: ptr
    r35 :: native_int
    r36 :: short_int
    r37 :: bit
    r38 :: object
    r39 :: str
    r40 :: object
    r41 :: bool
    r42 :: object[2]
    r43 :: object_ptr
    r44 :: object
    r45 :: bit
    r46 :: short_int
    r47 :: object
    r48 :: int
    r49 :: str
    r50 :: object
    r51 :: dict
    r52 :: str
    r53 :: object
    r54 :: i32
    r55 :: bit
    r56 :: tuple[object, object, object]
    r57 :: object
    r58 :: str
    r59 :: object
    r60 :: bit
    r61 :: list
    r62, r63, r64 :: object
    r65 :: i32
    r66 :: bit
    r67 :: bool
    r68 :: list
    r69 :: tuple
    r70 :: union[tuple, object]
    r71 :: i32
    r72, r73 :: bit
    r74 :: object
    r75 :: int
    r76 :: str
    r77 :: object
    r78 :: dict
    r79 :: str
    r80 :: object
    r81 :: i32
    r82, r83 :: bit
    r84 :: tuple[object, object, object]
    r85 :: object
    r86 :: str
    r87 :: object
    r88 :: bit
    r89 :: object
    r90 :: str
    r91 :: object
    r92 :: tuple
    r93 :: str
    r94 :: list
    r95 :: object
    r96 :: i32
    r97 :: bit
    r98 :: tuple
    r99 :: str
    r100 :: i32
    r101, r102 :: bit
    r103 :: str
    r104 :: object
    r105 :: dict
    r106 :: str
    r107 :: object
    r108, r109 :: int
L0:
    r0 = '__struct_config__'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L79 (error at __hash__:279) else goto L1
L1:
    r2 = 'frozen'
    r3 = CPyObject_GetAttr(r1, r2)
    dec_ref r1
    if is_error(r3) goto L79 (error at __hash__:279) else goto L2
L2:
    r4 = unbox(bool, r3)
    dec_ref r3
    if is_error(r4) goto L79 (error at __hash__:279) else goto L3
L3:
    if r4 goto L11 else goto L4 :: bool
L4:
    r5 = "unhashable type: '"
    r6 = PyObject_Type(self)
    r7 = '__name__'
    r8 = CPyObject_GetAttr(r6, r7)
    dec_ref r6
    if is_error(r8) goto L79 (error at __hash__:280) else goto L5
L5:
    r9 = cast(str, r8)
    if is_error(r9) goto L79 (error at __hash__:280) else goto L6
L6:
    r10 = "'"
    r11 = CPyStr_Build(3, r5, r9, r10)
    dec_ref r9
    if is_error(r11) goto L79 (error at __hash__:280) else goto L7
L7:
    r12 = builtins :: module
    r13 = 'TypeError'
    r14 = CPyObject_GetAttr(r12, r13)
    if is_error(r14) goto L80 (error at __hash__:280) else goto L8
L8:
    r15 = [r11]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r14, r16, 1, 0)
    dec_ref r14
    if is_error(r17) goto L80 (error at __hash__:280) else goto L9
L9:
    dec_ref r11
    CPy_Raise(r17)
    dec_ref r17
    if not 0 goto L79 (error at __hash__:280) else goto L10 :: bool
L10:
    unreachable
L11:
    r18 = '__dict__'
    r19 = CPyObject_GetAttr(self, r18)
    if is_error(r19) goto L79 (error at __hash__:281) else goto L12
L12:
    r20 = cast(dict, r19)
    if is_error(r20) goto L79 (error at __hash__:281) else goto L13
L13:
    r21 = '__hash__'
    r22 = CPyDict_GetWithNone(r20, r21)
    dec_ref r20
    if is_error(r22) goto L79 (error at __hash__:281) else goto L14
L14:
    inc_ref r22
    cached_hash = r22
    r23 = PyObject_IsTrue(r22)
    dec_ref r22
    r24 = r23 >= 0 :: signed
    if not r24 goto L81 (error at __hash__:281) else goto L15 :: bool
L15:
    r25 = truncate r23: i32 to builtins.bool
    if r25 goto L16 else goto L82 :: bool
L16:
    r26 = unbox(int, cached_hash)
    dec_ref cached_hash
    if is_error(r26) goto L79 (error at __hash__:282) else goto L17
L17:
    return r26
L18:
    r27 = '__struct_fields__'
    r28 = CPyObject_GetAttr(self, r27)
    if is_error(r28) goto L79 (error at __hash__:284) else goto L19
L19:
    r29 = cast(tuple, r28)
    if is_error(r29) goto L79 (error at __hash__:284) else goto L20
L20:
    r30 = get_element_ptr r29 ob_size :: PyVarObject
    r31 = load_mem r30 :: native_int*
    r32 = PyList_New(r31)
    if is_error(r32) goto L83 (error at __hash__:283) else goto L21
L21:
    r33 = 0
L22:
    r34 = get_element_ptr r29 ob_size :: PyVarObject
    r35 = load_mem r34 :: native_int*
    r36 = r35 << 1
    r37 = r33 < r36 :: signed
    if r37 goto L23 else goto L84 :: bool
L23:
    r38 = CPySequenceTuple_GetItem(r29, r33)
    if is_error(r38) goto L85 (error at __hash__:283) else goto L24
L24:
    r39 = cast(str, r38)
    if is_error(r39) goto L85 (error at __hash__:283) else goto L25
L25:
    r40 = dictstruct._main._getattribute :: static
    if is_error(r40) goto L86 else goto L28
L26:
    r41 = raise NameError('value for final name "_getattribute" was not set')
    if not r41 goto L79 (error at __hash__:284) else goto L27 :: bool
L27:
    unreachable
L28:
    r42 = [self, r39]
    r43 = load_address r42
    r44 = PyObject_Vectorcall(r40, r43, 2, 0)
    if is_error(r44) goto L87 (error at __hash__:284) else goto L29
L29:
    dec_ref r39
    r45 = CPyList_SetItemUnsafe(r32, r33, r44)
    if not r45 goto L85 (error at __hash__:283) else goto L30 :: bool
L30:
    r46 = r33 + 2
    r33 = r46
    goto L22
L31:
    r47 = PyObject_GetIter(r32)
    dec_ref r32
    if is_error(r47) goto L79 (error at __hash__:283) else goto L32
L32:
L33:
    r48 = CPyObject_Hash(r47)
    if is_error(r48) goto L37 (error at __hash__:289) else goto L34
L34:
    r49 = '__dict__'
    r50 = CPyObject_GetAttr(self, r49)
    if is_error(r50) goto L88 (error at __hash__:289) else goto L35
L35:
    r51 = cast(dict, r50)
    if is_error(r51) goto L88 (error at __hash__:289) else goto L36
L36:
    r52 = '__hash__'
    r53 = box(int, r48)
    r54 = CPyDict_SetItem(r51, r52, r53)
    dec_ref r51
    dec_ref r53
    r55 = r54 >= 0 :: signed
    if not r55 goto L37 (error at __hash__:289) else goto L89 :: bool
L37:
    r56 = CPy_CatchError()
    r57 = builtins :: module
    r58 = 'TypeError'
    r59 = CPyObject_GetAttr(r57, r58)
    if is_error(r59) goto L90 (error at __hash__:290) else goto L38
L38:
    r60 = CPy_ExceptionMatches(r59)
    dec_ref r59
    if r60 goto L39 else goto L91 :: bool
L39:
    r61 = PyList_New(0)
    if is_error(r61) goto L90 (error at __hash__:291) else goto L40
L40:
    r62 = PyObject_GetIter(r47)
    dec_ref r47
    if is_error(r62) goto L92 (error at __hash__:291) else goto L41
L41:
    r63 = PyIter_Next(r62)
    if is_error(r63) goto L93 else goto L42
L42:
    r64 = load_address PyList_Type
    r65 = PyObject_IsInstance(r63, r64)
    r66 = r65 >= 0 :: signed
    if not r66 goto L94 (error at __hash__:292) else goto L43 :: bool
L43:
    r67 = truncate r65: i32 to builtins.bool
    if r67 goto L44 else goto L47 :: bool
L44:
    r68 = cast(list, r63)
    if is_error(r68) goto L95 (error at __hash__:292) else goto L45
L45:
    r69 = PyList_AsTuple(r68)
    dec_ref r68
    if is_error(r69) goto L95 (error at __hash__:292) else goto L46
L46:
    r70 = r69
    goto L48
L47:
    r70 = r63
L48:
    r71 = PyList_Append(r61, r70)
    dec_ref r70
    r72 = r71 >= 0 :: signed
    if not r72 goto L95 (error at __hash__:291) else goto L41 :: bool
L49:
    r73 = CPy_NoErrOccurred()
    if not r73 goto L92 (error at __hash__:291) else goto L50 :: bool
L50:
    r74 = PyObject_GetIter(r61)
    dec_ref r61
    if is_error(r74) goto L58 (error at __hash__:291) else goto L51
L51:
    r75 = CPyObject_Hash(r74)
    dec_ref r74
    if is_error(r75) goto L58 (error at __hash__:291) else goto L52
L52:
    r76 = '__dict__'
    r77 = CPyObject_GetAttr(self, r76)
    if is_error(r77) goto L96 (error at __hash__:291) else goto L53
L53:
    r78 = cast(dict, r77)
    if is_error(r78) goto L96 (error at __hash__:291) else goto L54
L54:
    r79 = '__hash__'
    r80 = box(int, r75)
    r81 = CPyDict_SetItem(r78, r79, r80)
    dec_ref r78
    dec_ref r80
    r82 = r81 >= 0 :: signed
    if not r82 goto L58 (error at __hash__:291) else goto L57 :: bool
L55:
    CPy_Reraise()
    if not 0 goto L58 else goto L97 :: bool
L56:
    unreachable
L57:
    CPy_RestoreExcInfo(r56)
    dec_ref r56
    goto L74
L58:
    CPy_RestoreExcInfo(r56)
    dec_ref r56
    r83 = CPy_KeepPropagating()
    if not r83 goto L60 else goto L59 :: bool
L59:
    unreachable
L60:
    r84 = CPy_CatchError()
    r85 = builtins :: module
    r86 = 'Exception'
    r87 = CPyObject_GetAttr(r85, r86)
    if is_error(r87) goto L72 (error at __hash__:294) else goto L61
L61:
    r88 = CPy_ExceptionMatches(r87)
    dec_ref r87
    if r88 goto L62 else goto L69 :: bool
L62:
    r89 = CPy_GetExcValue()
    r90 = 'args'
    r91 = CPyObject_GetAttr(r89, r90)
    if is_error(r91) goto L98 (error at __hash__:295) else goto L63
L63:
    r92 = cast(tuple, r91)
    if is_error(r92) goto L98 (error at __hash__:295) else goto L64
L64:
    r93 = 'recursed in hash fn'
    r94 = PyList_New(0)
    if is_error(r94) goto L99 (error at __hash__:295) else goto L65
L65:
    r95 = CPyList_Extend(r94, r92)
    dec_ref r92
    if is_error(r95) goto L100 (error at __hash__:295) else goto L101
L66:
    r96 = PyList_Append(r94, r93)
    r97 = r96 >= 0 :: signed
    if not r97 goto L100 (error at __hash__:295) else goto L67 :: bool
L67:
    r98 = PyList_AsTuple(r94)
    dec_ref r94
    if is_error(r98) goto L98 (error at __hash__:295) else goto L68
L68:
    r99 = 'args'
    r100 = PyObject_SetAttr(r89, r99, r98)
    dec_ref r89
    dec_ref r98
    r101 = r100 >= 0 :: signed
    if not r101 goto L72 (error at __hash__:295) else goto L71 :: bool
L69:
    CPy_Reraise()
    if not 0 goto L72 else goto L102 :: bool
L70:
    unreachable
L71:
    CPy_RestoreExcInfo(r84)
    dec_ref r84
    goto L74
L72:
    CPy_RestoreExcInfo(r84)
    dec_ref r84
    r102 = CPy_KeepPropagating()
    if not r102 goto L79 else goto L73 :: bool
L73:
    unreachable
L74:
    r103 = '__dict__'
    r104 = CPyObject_GetAttr(self, r103)
    if is_error(r104) goto L79 (error at __hash__:296) else goto L75
L75:
    r105 = cast(dict, r104)
    if is_error(r105) goto L79 (error at __hash__:296) else goto L76
L76:
    r106 = '__hash__'
    r107 = CPyDict_GetItem(r105, r106)
    dec_ref r105
    if is_error(r107) goto L79 (error at __hash__:296) else goto L77
L77:
    r108 = unbox(int, r107)
    dec_ref r107
    if is_error(r108) goto L79 (error at __hash__:296) else goto L78
L78:
    return r108
L79:
    r109 = <error> :: int
    return r109
L80:
    dec_ref r11
    goto L79
L81:
    dec_ref cached_hash
    goto L79
L82:
    dec_ref cached_hash
    goto L18
L83:
    dec_ref r29
    goto L79
L84:
    dec_ref r29
    goto L31
L85:
    dec_ref r29
    dec_ref r32
    goto L79
L86:
    dec_ref r29
    dec_ref r32
    dec_ref r39
    goto L26
L87:
    dec_ref r29
    dec_ref r32
    dec_ref r39
    goto L79
L88:
    dec_ref r48 :: int
    goto L37
L89:
    dec_ref r47
    goto L74
L90:
    dec_ref r47
    goto L58
L91:
    dec_ref r47
    goto L55
L92:
    dec_ref r61
    goto L58
L93:
    dec_ref r62
    goto L49
L94:
    dec_ref r61
    dec_ref r62
    dec_ref r63
    goto L58
L95:
    dec_ref r61
    dec_ref r62
    goto L58
L96:
    dec_ref r75 :: int
    goto L58
L97:
    dec_ref r56
    goto L56
L98:
    dec_ref r89
    goto L72
L99:
    dec_ref r89
    dec_ref r92
    goto L72
L100:
    dec_ref r89
    dec_ref r94
    goto L72
L101:
    dec_ref r95
    goto L66
L102:
    dec_ref r84
    goto L70

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: object_ptr
    r10 :: object_ptr[1]
    r11 :: c_ptr
    r12 :: native_int[1]
    r13 :: c_ptr
    r14 :: object
    r15 :: dict
    r16, r17 :: str
    r18 :: bit
    r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: object
    r26 :: dict
    r27 :: str
    r28 :: i32
    r29 :: bit
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: str
    r34 :: object
    r35 :: dict
    r36 :: str
    r37 :: i32
    r38 :: bit
    r39 :: object
    r40 :: str
    r41 :: object
    r42 :: tuple
    r43, r44 :: object
    r45 :: str
    r46 :: bool
    r47, r48 :: str
    r49 :: object
    r50 :: object[2]
    r51 :: object_ptr
    r52 :: object
    r53, r54, r55, r56 :: dict
    r57 :: dictstruct._main.__bool___DictStruct_obj
    r58 :: str
    r59 :: i32
    r60 :: bit
    r61 :: dictstruct._main.__contains___DictStruct_obj
    r62 :: str
    r63 :: i32
    r64 :: bit
    r65 :: dictstruct._main.get_DictStruct_obj
    r66 :: str
    r67 :: i32
    r68 :: bit
    r69 :: dictstruct._main.__getitem___DictStruct_obj
    r70 :: str
    r71 :: i32
    r72 :: bit
    r73 :: dictstruct._main.__getattribute___DictStruct_obj
    r74 :: str
    r75 :: i32
    r76 :: bit
    r77 :: dictstruct._main.__setitem___DictStruct_obj
    r78 :: str
    r79 :: i32
    r80 :: bit
    r81 :: dictstruct._main.__iter___DictStruct_obj
    r82 :: str
    r83 :: i32
    r84 :: bit
    r85 :: dictstruct._main.__len___DictStruct_obj
    r86 :: str
    r87 :: i32
    r88 :: bit
    r89 :: dictstruct._main.keys_DictStruct_obj
    r90 :: str
    r91 :: i32
    r92 :: bit
    r93 :: dictstruct._main.items_DictStruct_obj
    r94 :: str
    r95 :: i32
    r96 :: bit
    r97 :: dictstruct._main.values_DictStruct_obj
    r98 :: str
    r99 :: i32
    r100 :: bit
    r101 :: dictstruct._main.__hash___DictStruct_obj
    r102 :: str
    r103 :: i32
    r104 :: bit
    r105, r106 :: str
    r107 :: i32
    r108 :: bit
    r109, r110 :: str
    r111 :: i32
    r112 :: bit
    r113, r114 :: str
    r115 :: i32
    r116 :: bit
    r117 :: object[3]
    r118 :: object_ptr
    r119 :: object
    r120 :: dict
    r121 :: str
    r122, r123 :: object
    r124 :: object[1]
    r125 :: object_ptr
    r126, r127 :: object
    r128 :: object[1]
    r129 :: object_ptr
    r130 :: object
    r131 :: dict
    r132 :: str
    r133 :: i32
    r134 :: bit
    r135 :: object
    r136 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L55 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any', 'Final', 'Iterator', 'Literal', 'Tuple')
    r6 = 'typing'
    r7 = dictstruct._main.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L55 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = load_address msgspec :: module
    r10 = [r9]
    r11 = load_address r10
    r12 = [3]
    r13 = load_address r12
    r14 = (('msgspec', 'msgspec', 'msgspec'),)
    r15 = dictstruct._main.globals :: static
    r16 = 'dictstruct/_main.py'
    r17 = '<module>'
    r18 = CPyImport_ImportMany(r14, r11, r15, r16, r17, r13)
    if not r18 goto L55 else goto L5 :: bool
L5:
    r19 = ('mypyc_attr',)
    r20 = 'mypy_extensions'
    r21 = dictstruct._main.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L55 (error at <module>:4) else goto L6
L6:
    mypy_extensions = r22 :: module
    dec_ref r22
    r23 = msgspec :: module
    r24 = 'UNSET'
    r25 = CPyObject_GetAttr(r23, r24)
    if is_error(r25) goto L55 (error at <module>:7) else goto L7
L7:
    dictstruct._main.UNSET = r25 :: static
    r26 = dictstruct._main.globals :: static
    r27 = 'UNSET'
    r28 = CPyDict_SetItem(r26, r27, r25)
    dec_ref r25
    r29 = r28 >= 0 :: signed
    if not r29 goto L55 (error at <module>:7) else goto L8 :: bool
L8:
    r30 = builtins :: module
    r31 = 'object'
    r32 = CPyObject_GetAttr(r30, r31)
    if is_error(r32) goto L55 (error at <module>:9) else goto L9
L9:
    r33 = '__getattribute__'
    r34 = CPyObject_GetAttr(r32, r33)
    dec_ref r32
    if is_error(r34) goto L55 (error at <module>:9) else goto L10
L10:
    dictstruct._main._getattribute = r34 :: static
    r35 = dictstruct._main.globals :: static
    r36 = '_getattribute'
    r37 = CPyDict_SetItem(r35, r36, r34)
    dec_ref r34
    r38 = r37 >= 0 :: signed
    if not r38 goto L55 (error at <module>:9) else goto L11 :: bool
L11:
    r39 = msgspec :: module
    r40 = 'Struct'
    r41 = CPyObject_GetAttr(r39, r40)
    if is_error(r41) goto L55 (error at <module>:13) else goto L12
L12:
    r42 = PyTuple_Pack(1, r41)
    dec_ref r41
    if is_error(r42) goto L55 (error at <module>:13) else goto L13
L13:
    r43 = load_address PyType_Type
    r44 = CPy_CalculateMetaclass(r43, r42)
    if is_error(r44) goto L56 (error at <module>:13) else goto L14
L14:
    r45 = '__prepare__'
    r46 = PyObject_HasAttr(r44, r45)
    if r46 goto L15 else goto L19 :: bool
L15:
    r47 = 'DictStruct'
    r48 = '__prepare__'
    r49 = CPyObject_GetAttr(r44, r48)
    if is_error(r49) goto L56 (error at <module>:13) else goto L16
L16:
    r50 = [r47, r42]
    r51 = load_address r50
    r52 = PyObject_Vectorcall(r49, r51, 2, 0)
    dec_ref r49
    if is_error(r52) goto L56 (error at <module>:13) else goto L17
L17:
    r53 = cast(dict, r52)
    if is_error(r53) goto L56 (error at <module>:13) else goto L18
L18:
    r54 = r53
    goto L21
L19:
    r55 = PyDict_New()
    if is_error(r55) goto L56 (error at <module>:13) else goto L20
L20:
    r54 = r55
L21:
    r56 = PyDict_New()
    if is_error(r56) goto L57 (error at <module>:13) else goto L22
L22:
    r57 = __bool___DictStruct_obj()
    if is_error(r57) goto L58 (error at <module>:44) else goto L23
L23:
    r58 = '__bool__'
    r59 = CPyDict_SetItem(r54, r58, r57)
    dec_ref r57
    r60 = r59 >= 0 :: signed
    if not r60 goto L58 (error at <module>:44) else goto L24 :: bool
L24:
    r61 = __contains___DictStruct_obj()
    if is_error(r61) goto L58 (error at <module>:55) else goto L25
L25:
    r62 = '__contains__'
    r63 = CPyDict_SetItem(r54, r62, r61)
    dec_ref r61
    r64 = r63 >= 0 :: signed
    if not r64 goto L58 (error at <module>:55) else goto L26 :: bool
L26:
    r65 = get_DictStruct_obj()
    if is_error(r65) goto L58 (error at <module>:76) else goto L27
L27:
    r66 = 'get'
    r67 = CPyDict_SetItem(r54, r66, r65)
    dec_ref r65
    r68 = r67 >= 0 :: signed
    if not r68 goto L58 (error at <module>:76) else goto L28 :: bool
L28:
    r69 = __getitem___DictStruct_obj()
    if is_error(r69) goto L58 (error at <module>:95) else goto L29
L29:
    r70 = '__getitem__'
    r71 = CPyDict_SetItem(r54, r70, r69)
    dec_ref r69
    r72 = r71 >= 0 :: signed
    if not r72 goto L58 (error at <module>:95) else goto L30 :: bool
L30:
    r73 = __getattribute___DictStruct_obj()
    if is_error(r73) goto L58 (error at <module>:121) else goto L31
L31:
    r74 = '__getattribute__'
    r75 = CPyDict_SetItem(r54, r74, r73)
    dec_ref r73
    r76 = r75 >= 0 :: signed
    if not r76 goto L58 (error at <module>:121) else goto L32 :: bool
L32:
    r77 = __setitem___DictStruct_obj()
    if is_error(r77) goto L58 (error at <module>:150) else goto L33
L33:
    r78 = '__setitem__'
    r79 = CPyDict_SetItem(r54, r78, r77)
    dec_ref r77
    r80 = r79 >= 0 :: signed
    if not r80 goto L58 (error at <module>:150) else goto L34 :: bool
L34:
    r81 = __iter___DictStruct_obj()
    if is_error(r81) goto L58 (error at <module>:180) else goto L35
L35:
    r82 = '__iter__'
    r83 = CPyDict_SetItem(r54, r82, r81)
    dec_ref r81
    r84 = r83 >= 0 :: signed
    if not r84 goto L58 (error at <module>:180) else goto L36 :: bool
L36:
    r85 = __len___DictStruct_obj()
    if is_error(r85) goto L58 (error at <module>:200) else goto L37
L37:
    r86 = '__len__'
    r87 = CPyDict_SetItem(r54, r86, r85)
    dec_ref r85
    r88 = r87 >= 0 :: signed
    if not r88 goto L58 (error at <module>:200) else goto L38 :: bool
L38:
    r89 = keys_DictStruct_obj()
    if is_error(r89) goto L58 (error at <module>:214) else goto L39
L39:
    r90 = 'keys'
    r91 = CPyDict_SetItem(r54, r90, r89)
    dec_ref r89
    r92 = r91 >= 0 :: signed
    if not r92 goto L58 (error at <module>:214) else goto L40 :: bool
L40:
    r93 = items_DictStruct_obj()
    if is_error(r93) goto L58 (error at <module>:228) else goto L41
L41:
    r94 = 'items'
    r95 = CPyDict_SetItem(r54, r94, r93)
    dec_ref r93
    r96 = r95 >= 0 :: signed
    if not r96 goto L58 (error at <module>:228) else goto L42 :: bool
L42:
    r97 = values_DictStruct_obj()
    if is_error(r97) goto L58 (error at <module>:245) else goto L43
L43:
    r98 = 'values'
    r99 = CPyDict_SetItem(r54, r98, r97)
    dec_ref r97
    r100 = r99 >= 0 :: signed
    if not r100 goto L58 (error at <module>:245) else goto L44 :: bool
L44:
    r101 = __hash___DictStruct_obj()
    if is_error(r101) goto L58 (error at <module>:262) else goto L45
L45:
    r102 = '__hash__'
    r103 = CPyDict_SetItem(r54, r102, r101)
    dec_ref r101
    r104 = r103 >= 0 :: signed
    if not r104 goto L58 (error at <module>:262) else goto L46 :: bool
L46:
    r105 = 'DictStruct'
    r106 = '__annotations__'
    r107 = CPyDict_SetItem(r54, r106, r56)
    dec_ref r56
    r108 = r107 >= 0 :: signed
    if not r108 goto L57 (error at <module>:13) else goto L47 :: bool
L47:
    r109 = 'mypyc filler docstring'
    r110 = '__doc__'
    r111 = CPyDict_SetItem(r54, r110, r109)
    r112 = r111 >= 0 :: signed
    if not r112 goto L57 (error at <module>:13) else goto L48 :: bool
L48:
    r113 = 'dictstruct._main'
    r114 = '__module__'
    r115 = CPyDict_SetItem(r54, r114, r113)
    r116 = r115 >= 0 :: signed
    if not r116 goto L57 (error at <module>:13) else goto L49 :: bool
L49:
    r117 = [r105, r42, r54]
    r118 = load_address r117
    r119 = PyObject_Vectorcall(r44, r118, 3, 0)
    if is_error(r119) goto L57 (error at <module>:13) else goto L50
L50:
    dec_ref r54
    dec_ref r42
    r120 = dictstruct._main.globals :: static
    r121 = 'mypyc_attr'
    r122 = CPyDict_GetItem(r120, r121)
    if is_error(r122) goto L59 (error at <module>:12) else goto L51
L51:
    r123 = box(bool, 0)
    r124 = [r123]
    r125 = load_address r124
    r126 = ('native_class',)
    r127 = PyObject_Vectorcall(r122, r125, 0, r126)
    dec_ref r122
    if is_error(r127) goto L59 (error at <module>:12) else goto L52
L52:
    r128 = [r119]
    r129 = load_address r128
    r130 = PyObject_Vectorcall(r127, r129, 1, 0)
    dec_ref r127
    if is_error(r130) goto L59 (error at <module>:13) else goto L53
L53:
    dec_ref r119
    dictstruct._main.DictStruct = r130 :: type
    r131 = dictstruct._main.globals :: static
    r132 = 'DictStruct'
    r133 = CPyDict_SetItem(r131, r132, r130)
    dec_ref r130
    r134 = r133 >= 0 :: signed
    if not r134 goto L55 (error at <module>:13) else goto L54 :: bool
L54:
    r135 = dictstruct._main.DictStruct :: type
    return 1
L55:
    r136 = <error> :: None
    return r136
L56:
    dec_ref r42
    goto L55
L57:
    dec_ref r42
    dec_ref r54
    goto L55
L58:
    dec_ref r42
    dec_ref r54
    dec_ref r56
    goto L55
L59:
    dec_ref r119
    goto L55
